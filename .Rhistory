prop.UW
prop.UT = n*Wh.UT
prop.UT
#d)
muh.UW = 150
muh.UT = 70
muhat.strat = Wh.UW*muh.UW + Wh.UT*muh.UT
muhat.strat
#e)
cv
nh = c(nh.UW, nh.UT)
Nh = c(Nh.UW, Nh.UT)
Wh = c(Wh.UW, Wh.UT)
muh = c(muh.UW, muh.UT)
sigma2hat = c(10, 20)
#getting variance
var.str = sum(Wh^2 * (1-(nh/Nh)) * (sigma2hat/nh))
var.str
#CI
CI = muhat.strat + cv*sqrt(var.str)
CI
1-2*0.2
knitr::opts_chunk$set(echo = TRUE)
library(boot)
set.seed(1413)
mytrimmedmean = function(x,i){mean(x[i], trim=0.2)}
q2a = boot(x, mytrimmedmean, 1000)
q2a
x <- c(78, 86, 97, 91, 83, 89, 92, 88, 79, 68)
q2a = boot(x, mytrimmedmean, 1000)
q2a
summary(q2a)
criticalvalues = c(qnorm(0.9/2, lower.tail = TRUE),
qnorm(0.9/2, lower.tail = FALSE))
criticalvalues
criticalvalues = c(qnorm(1-0.9/2, lower.tail = TRUE),
qnorm(1-0.9/2, lower.tail = FALSE))
criticalvalues = c(qnorm(1-0.9/2, lower.tail = TRUE),
criticalvalues = c(qnorm(1-0.9/2, lower.tail = TRUE),
criticalvalues = c(qnorm(1-0.9/2, lower.tail = TRUE),
qnorm(1-0.9/2, lower.tail = FALSE))
criticalvalues
criticalvalues = c(qnorm(0.1/2, lower.tail = TRUE),
qnorm(0.1/2, lower.tail = FALSE))
criticalvalues
q2a
str(q2a)
sd(q2a$t)
mytrimmedmean(x)
#install.package("mlbench") if needed
library(mlbench)
data("PimaIndiansDiabetes2", package = "mlbench")
mydata <- PimaIndiansDiabetes2
summary(mydata)
names(mydata)
testing  = mydata
testing  = head(mydata)
testing
testing[-1,]
testing
for (i in names(testing)){
for (j in 1:nrow(testing)){
if (is.na(testing[j, i])){
testing = testing[-j,]
}
}
}
testing
str(testing$insulin)
is.na(testing$insulin[1])
for (i in names(testing)){
for (j in 1:nrow(testing)){
if (is.na(testing[j, i])){
testing = testing[-j,]
}
}
}
testing
500+268
768-374
knitr::opts_chunk$set(echo = TRUE)
?step()
#install.package("mlbench") if needed
library(mlbench)
data("PimaIndiansDiabetes2", package = "mlbench")
mydata <- PimaIndiansDiabetes2
head(mydata)
str(mydata)
lm(mydata$diabetes ~ mydata$glucose)
plot(lm(mydata$diabetes ~ mydata$glucose))
plot(glm(mydata$diabetes ~ mydata$glucose))
plot(glm(mydata$diabetes ~ mydata$glucose, family=binomial))
plot(mydata$diabetes ~ mydata$glucose)
28/7
#DATA543 Quiz 2
#Jonah Edmundson
hortons = read.csv('./Tweets.csv')
getwd()
install.packages("mcmc")
install.packages("hmm")
install.packages("HMM")
exit
#q1
P = matrix(c(0.9, 0.1, 0, 0, 0, 0,
0.1, 0.85, 0.05, 0, 0, 0,
0, 0.1, 0.8, 0.1, 0, 0,
0, 0, 0.1, 0.8, 0.1, 0,
0, 0, 0, 0.1, 0.8, 0.1,
0, 0, 0, 0, 0.1, 0.9), nrow=6)
P
P%*%P%*%P
P%*%P
#q1
P = matrix(c(0.9, 0.1, 0, 0, 0, 0,
0.1, 0.85, 0.05, 0, 0, 0,
0, 0.1, 0.8, 0.1, 0, 0,
0, 0, 0.1, 0.8, 0.1, 0,
0, 0, 0, 0.05, 0.85, 0.1,
0, 0, 0, 0, 0.1, 0.9), nrow=6)
P%*%P
(P%*%P)[2,3]
P
#q1
P = matrix(c(0.9, 0.1, 0, 0, 0, 0,
0.1, 0.85, 0.05, 0, 0, 0,
0, 0.1, 0.8, 0.1, 0, 0,
0, 0, 0.1, 0.8, 0.1, 0,
0, 0, 0, 0.05, 0.85, 0.1,
0, 0, 0, 0, 0.1, 0.9), nrow=6)
P
options(digits=4)
P
#q1
P = matrix(c(0.9, 0.1, 0, 0, 0, 0,
0.1, 0.85, 0.05, 0, 0, 0,
0, 0.1, 0.8, 0.1, 0, 0,
0, 0, 0.1, 0.8, 0.1, 0,
0, 0, 0, 0.05, 0.85, 0.1,
0, 0, 0, 0, 0.1, 0.9), nrow=6, byrow = TRUE)
P
(P%*%P)[2,3]
#q2
#if time-reversible, qP=q should be true
q = matrix(0.2, 0.2, 0.1, 0.1, 0.2, 0.2,
nrow=1, byrow = TRUE)
#q2
#if time-reversible, qP=q should be true
q = matrix(c(0.2, 0.2, 0.1, 0.1, 0.2, 0.2),
nrow=1, byrow = TRUE)
q
q%*%P
q%*%P == q
all.equal(q%*%P, q)
#q2
transm = matrix(c(0.1, 0.2, 0.7,
0.8, 0, 0.2,
0.7, 0.3, 0),
nrow=3, byrow = TRUE)
transm
emm = matrix(c(0.1, 0.1, 0.8, 0,
0.2, 0.2, 0.6, 0,
0.3, 0.1, 0.4, 0.2),
nrow = 3, byrow = TRUE)
emm
obsdata = c(2, 4, 3, 3, 3, 3, 3, 3, 2, 3, 1,
3, 2, 2, 3, 1, 3, 3, 4, 1)
matrix(c(1, 2, 2, 1)/3,2)
#q2
transm = matrix(c(0.1, 0.2, 0.7,
0.8, 0, 0.2,
0.7, 0.3, 0),
nrow=3, byrow = TRUE)
emm = matrix(c(0.1, 0.1, 0.8, 0,
0.2, 0.2, 0.6, 0,
0.3, 0.1, 0.4, 0.2),
nrow = 3, byrow = TRUE)
obsdata = as.character(c(2, 4, 3, 3, 3, 3, 3, 3, 2, 3, 1,
3, 2, 2, 3, 1, 3, 3, 4, 1))
library(HMM)
hmm = initHMM(c("1","2", "3"), c("1","2", "3", "4"),
transProbs=transm,
emissionProbs=emm)
viterbi = viterbi(hmm, obsdata)
print(viterbi)
viterbi
simDataFit = viterbiTraining(hmm, obsdata)
simDataFit
#q3
#a)
q3sim = simHMM(simDataFit$hmm, 10000)
summary(q3sim)
hea(q3sim)
head(q3sim)
head(q3sim$observation)
table(q3sim$observation)
table(q3sim$observation)/length(q3sim$observation)
table(q3sim$states)/length(q3sim$observation)
#q3
#a)
#q3sim = simHMM(simDataFit$hmm, 10000)
#table(q3sim$states)/length(q3sim$observation)
A = t(transm) - diag(rep(1, 3))
A = rbind(A, rep(1,3))
RHS = c(rep(0,3), 1)
pi = qr.solve(A, RHS)
pi
#b)
#from state 1 and 2 --> obs 4 is 0
#multiply state 3 --> obs 4
pi[3]*emm[3,4]
#c)
#if we're in obs 4 at time 1, then the prob of being in
#each hidden state is just emm col 4
#only way to be in obs 4 is by state 3,
#so we are 100% in hidden state 3 to start
#we want probability of STAYING in hidden state 3
#in the next time step
transm[3,3]
1:3
knitr::opts_chunk$set(echo = TRUE)
transm = matrix(c(0, 0, 0.7, 0.3,
0.8, 0, 0.2, 0,
0.7, 0.3, 0, 0,
0.1, 0.1, 0.8, 0),
nrow=4, byrow=TRUE)
emm = matrix(c(0, 0, 0.8, 0, 0.2,
0.2, 0, 0, 0.2, 0.6,
0.3, 0, 0.4, 0, 0.3,
0.7, 0.2, 0, 0.1, 0),
nrow=4, byrow=TRUE)
transm
emm
P%*%(P%*%P)
P = matrix(c(0, 0.5, 0.5,
0.5, 0, 0.5,
0.5, 0.5, 0), nrow=3, byrow = TRUE)
P%*%(P%*%P)
(P%*%P)%*%P
install.packages('Hmisc')
warnings()
install.packages('Hmisc')
install.packages('Hmisc')
library('roxygen2')
ls()
exit
install.packages("covr")
?try
req = httr::content(httr::GET('https://world.openfoodfacts.org/cgi/search.pl?action=process&tagtype_0=categories&tag_contains_0=contains&tag_0=cereals'), 'text')
?read_html
??read_html
xml2::read_html(req)
hi = xml2::read_html(req)
hi
hi[1]
hi[2]
xml2::xml_find_all(hi[2], "<a")
xml2::xml_find_all(hi[2]$doc, "<a")
xml2::xml_find_all(hi, "<a")
??xml_find_all
xml2::xml_find_all(hi, "//ul[]")
xml2::xml_find_all(hi, "//")
xml2::xml_find_all(hi, "/")
xml2::xml_find_all(hi, ".//*[a]")
alla = xml2::xml_find_all(hi, ".//*[a]")
alla
alla[4]
??xml2
?xml2
??xml2
xml2::xml_contents(alla[4])
xml2::xml_contents(alla[5])
xml2::xml_contents(alla[6])
xml2::xml_contents(alla[6][1])
alla[6]
alla = xml2::xml_find_all(hi, ".//*[li]")
alla
alla = xml2::xml_find_all(hi, ".//li")
alla
alla[21]
xml2::as_list(alla[21])
alla = xml2::xml_find_all(hi, ".//ul[@id='products_match_all']/li")
alla
hi
alla = xml2::xml_find_all(hi, "//*[@id="products_match_all"]")
alla = xml2::xml_find_all(hi, "//*[@id='products_match_all']")
alla
alla[1]
req = httr::content(httr::GET('https://world.openfoodfacts.org/cgi/search.pl?action=process&tagtype_0=categories&tag_contains_0=contains&tag_0=cereals'), 'text')
req
alla = xml2::xml_find_all(req, "//*[@id='products_match_all']")
req = httr::content(httr::GET('https://world.openfoodfacts.org/cgi/search.pl?action=process&tagtype_0=categories&tag_contains_0=contains&tag_0=cereals'), 'parse')
alla = xml2::xml_find_all(req, "//*[@id='products_match_all']")
alla
alla = xml2::xml_find_all(req, "//*[@id='products_match_all']/li")
allla
alla
alla = xml2::xml_find_all(req, ".//*[@id='products_match_all']/li")
alla
alla = xml2::xml_find_all(req, ".//*[@id='products_match_all'")
alla = xml2::xml_find_all(req, ".//*[@id='products_match_all']")
alla
xml2::xml_contents(alla[6])
alla = xml2::xml_find_all(req, ".//*[a]")
alla
alla = xml2::xml_find_all(req, ".//*a[@class='list_product_a']")
alla = xml2::xml_find_all(req, ".//*[@class='list_product_a']")
alla
alla = xml2::xml_find_all(req, ".//*[list_product_a]")
alla
alla = xml2::xml_find_all(req, ".//*[a]")
alla
alla[6]
xml2::content(alla[6])
xml2::cotents(alla[6])
xml2::contents(alla[6])
xml2::xml_contents(alla[6])
xml2::xml_contents(alla[6])[1]
xml2::html_contents(alla[6])[1]
??xml_contents
xml2::html_children(alla[6])[1]
xml2::xml_children(alla[6])[1]
xml2::xml_children(alla[6][1])[1]
alla[6]
str(alla[6])
xml2::xml_children(alla)[1]
xml2::xml_children(alla)
alla
req
resXML <- htmlParse(content(req, as = "text"))
resXML <- XML::htmlParse(content(req, as = "text"))
install.packages("XML")
resXML <- XML::htmlParse(content(req, as = "text"))
resXML <- XML::htmlParse(httr::content(req, as = "text"))
resXML <- XML::htmlParse(req)
resXML
getNodeSet(resXML, '//li')
XML::getNodeSet(resXML, '//li')
XML::getNodeSet(resXML, './/*[@class='list_product_a')
XML::getNodeSet(resXML, "//*[@class='list_product_a']")
resXML
XML::getNodeSet(resXML, "//*[@class='products']")
XML::getNodeSet(resXML, "//*[@class='products']/li")
XML::getNodeSet(resXML, "//*[@class='products']/li")[[1]]
lst = XML::getNodeSet(resXML, "//*[@class='products']/li")
lst
lst[1]
lst[[1]]
str(lst[[1]])
XML::getChildrenStrings(lst[[1]])
XML::xmlValue(lst[[1]])
?grep
grep('title=', lst[[1]])
as.character(lst[[1]])
lst[[1]]
toString(lst[[1]])
XML::getChildrenStrings(lst[[1]])
XML::toString.XMLNode(lst[[1]])
grep('title=', XML::toString.XMLNode(lst[[1]]))
sub('title=', XML::toString.XMLNode(lst[[1]]))
sub('title=', '', XML::toString.XMLNode(lst[[1]]))
grep('title=', XML::toString.XMLNode(lst[[1]]), value=TRUE)
grep('title=\"*"', XML::toString.XMLNode(lst[[1]]), value=TRUE)
grep('title=\"*\"', XML::toString.XMLNode(lst[[1]]), value=TRUE)
grep('title=\".*?\"', XML::toString.XMLNode(lst[[1]]), value=TRUE)
grep('title=\\.*?\\', XML::toString.XMLNode(lst[[1]]), value=TRUE)
grep('title=".*?"', XML::toString.XMLNode(lst[[1]]), value=TRUE)
grep('title=".*?">', XML::toString.XMLNode(lst[[1]]), value=TRUE)
grep('title= .* ">\n', XML::toString.XMLNode(lst[[1]]), value=TRUE)
grep('title= .* ">', XML::toString.XMLNode(lst[[1]]), value=TRUE)
grep('title= .* "', XML::toString.XMLNode(lst[[1]]), value=TRUE)
grep('title= .* \"', XML::toString.XMLNode(lst[[1]]), value=TRUE)
grep('title=.* \"', XML::toString.XMLNode(lst[[1]]), value=TRUE)
grep('title=.*\"', XML::toString.XMLNode(lst[[1]]), value=TRUE)
grep('<span>.*</span>', XML::toString.XMLNode(lst[[1]]), value=TRUE)
regmatches('<span>.*</span>', XML::toString.XMLNode(lst[[1]]))
regmatches(XML::toString.XMLNode(lst[[1]]),regexpr("<span>.*</span>",XML::toString.XMLNode(lst[[1]])))
regexpr("<span>.*</span>",XML::toString.XMLNode(lst[[1]]))
gregexpr("<span>.*</span>",XML::toString.XMLNode(lst[[1]]))
> sub("<span>.*</span>", "\\1", XML::toString.XMLNode(lst[[1]]) ,perl=TRUE)
sub("<span>.*</span>", "\\1", XML::toString.XMLNode(lst[[1]]) ,perl=TRUE)
gsub(".*<span>|</span>.*", "", XML::toString.XMLNode(lst[[1]]))
len(lst)
length(lst)
gsub(".*href=\"\product/|/.*", "", XML::toString.XMLNode(lst[[1]]))
gsub(".*href=\"/product/|/.*", "", XML::toString.XMLNode(lst[[1]]))
search = function(term){
require(httr); require(XML)
req = httr::content(httr::GET('https://world.openfoodfacts.org/cgi/search.pl?action=process&tagtype_0=categories&tag_contains_0=contains&tag_0=cereals'), 'parse')
resXML = XML::htmlParse(req)
lst = XML::getNodeSet(resXML, "//*[@class='products']/li")
titles = c()
prodnums = c()
for (i in 1:length(lst)){
titles = c(titles, gsub(".*<span>|</span>.*", "", XML::toString.XMLNode(lst[[i]])))
prodnums = c(prodnums, gsub(".*href=\"/product/|/.*", "", XML::toString.XMLNode(lst[[i]])))
}
return(data.frame(titles, prodnums))
}
search()
search = function(term){
require(httr); require(XML)
req = httr::content(httr::GET(paste0('https://world.openfoodfacts.org/cgi/search.pl?search_terms=', term, '&search_simple=1&action=process')), 'parse')
resXML = XML::htmlParse(req)
lst = XML::getNodeSet(resXML, "//*[@class='products']/li")
titles = c()
prodnums = c()
for (i in 1:length(lst)){
titles = c(titles, gsub(".*<span>|</span>.*", "", XML::toString.XMLNode(lst[[i]])))
prodnums = c(prodnums, gsub(".*href=\"/product/|/.*", "", XML::toString.XMLNode(lst[[i]])))
}
return(data.frame(titles, prodnums))
}
search(eggs)
search('eggs')
setwd('/home/jonah/mds/openFood_wrappeR/openFood_wrappeR')
getwd()
setwd('/home/jonah/mds/openFood_wrappeR/openFoodwrappeR')
getwd()
library(devtools)
library(openFoodwrappeR)
openFoodwrappeR::product('eggs')
getAnywhere(openFoodwrappeR)
getAnywhere(openFoodwrappeR::)
getAnywhere(where='openFoodwrappeR')
getAnywhere('openFoodwrappeR')
ls()
mget()
mget(test)
mget('test')
search()
ls(package:openFoodwrappeR)
ls("package:openFoodwrappeR")
?openFoodwrappeR
??openFoodwrappeR
lsp <- function (package, all.names = FALSE, pattern) {
package <- deparse(substitute(package))
ls(pos = paste("package", package, sep = ":"), all.names = all.names,
pattern = pattern)
}
lsp
lsp('openFoodwrappeR')
lsp(openFoodwrappeR)
load_all("./")
ls()
openFoodwrappeR::calls()
openFoodwrappeR::product()
import("./")
R.calls
load_all("./R/calls.R")
openFoodwrappeR::product()
source("./")
source("./R/calls.R")
ls()
ls
ls()
source("./")
source("./R/")
source_all("./R/")
sd()
?sd
#' Search Product by Name
#'
#' This function allows you to express your love of cats.
#' @param term The name of the product to search for.
#' @export
#' @examples
#' search_by_name()
search_by_name = function(term){
require(httr); require(XML)
req = httr::content(httr::GET(paste0('https://world.openfoodfacts.org/cgi/search.pl?search_terms=', term, '&search_simple=1&action=process')), 'parse')
resXML = XML::htmlParse(req)
lst = XML::getNodeSet(resXML, "//*[@class='products']/li")
titles = c()
prodnums = c()
for (i in 1:length(lst)){
titles = c(titles, gsub(".*<span>|</span>.*", "", XML::toString.XMLNode(lst[[i]])))
prodnums = c(prodnums, gsub(".*href=\"/product/|/.*", "", XML::toString.XMLNode(lst[[i]])))
}
return(data.frame('titles'=as.character(titles), 'prodnums'=as.character(prodnums)))
}
#' Build URL
#'
#' This function builds the .json product URL.
#' @param prodnum The product number. Passed from product function.
#' @export
#' @examples
#' build_URL()
build_URL = function(prodnum, country = 'world', filters=''){
return(paste0('https://', country, '-en.openfoodfacts.org/api/v0/product/', prodnum, '.json'))
}
#' Get a product.
#'
#' This function retrieves a .json file for a product.
#' @param term The name of the product to search for.
#' @export
#' @examples
#' product()
product = function(term){
lst = search_by_name(term, chars=30)
cat("Number", "\t | \t", "Name", "\n")
cat("-------------------", "\n")
for (i in 1:nrow(lst)){
cat(i, "\t | \t", substr(as.character(lst[i, 1]), 1, chars), " ... \n")
Sys.sleep(0.15)
}
cat("Please select the \'Number\' of the product: \n")
num = readline()
url = build_URL(lst[num, 2])
return(jsonlite::fromJSON(txt=url))
}
x = product('eggs')
chars
